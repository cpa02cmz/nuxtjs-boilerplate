generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider  = "postgresql"
  url       = env("DATABASE_URL")
  directUrl = env("DATABASE_URL")
}

model AnalyticsEvent {
  id         String    @id @default(cuid())
  type       String
  resourceId String?
  category   String?
  url        String?
  userAgent  String?
  ip         String?
  timestamp  DateTime
  properties String?
  deletedAt  DateTime?

  // Optimized indexes (5 total, reduced from 7)
  // Removed: @@index([timestamp]) - covered by composite indexes with timestamp prefix
  // Removed: @@index([resourceId, type]) - covered by comprehensive index below
  @@index([timestamp, type]) // Time + event type queries
  @@index([timestamp, resourceId]) // Time + resource lookups
  @@index([ip, timestamp]) // IP time-series analysis (unique access pattern)
  @@index([category, timestamp]) // Category analytics (unique access pattern)
  @@index([resourceId, type, timestamp, deletedAt]) // Comprehensive analytics with soft delete
}

model RateLimit {
  id        String   @id @default(cuid())
  key       String // IP address or user identifier
  window    DateTime // Time window start (minute buckets)
  count     Int      @default(0)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([key, window])
  @@index([window]) // For cleanup queries
}

model Webhook {
  id          String              @id @default(cuid())
  url         String
  secret      String?
  active      Boolean             @default(true)
  events      String
  createdAt   DateTime            @default(now())
  updatedAt   DateTime            @updatedAt
  deletedAt   DateTime?
  deliveries  WebhookDelivery[]
  queueItems  WebhookQueue[]
  deadLetters DeadLetterWebhook[]

  @@index([active])
  @@index([deletedAt])
  @@index([active, deletedAt])
  @@index([url])
}

model WebhookDelivery {
  id              String           @id @default(cuid())
  webhookId       String
  webhook         Webhook          @relation(fields: [webhookId], references: [id], onDelete: Cascade)
  event           String
  payload         String
  status          String           @default("pending")
  statusCode      Int?
  responseBody    String?
  errorMessage    String?
  attemptCount    Int              @default(1)
  idempotencyKey  String?
  createdAt       DateTime         @default(now())
  updatedAt       DateTime         @updatedAt
  deletedAt       DateTime?
  idempotencyKeys IdempotencyKey[]

  @@index([webhookId])
  @@index([idempotencyKey])
  @@index([status])
  @@index([createdAt])
  @@index([webhookId, status])
  @@index([deletedAt])
}

model WebhookQueue {
  id                  String    @id @default(cuid())
  webhookId           String
  webhook             Webhook   @relation(fields: [webhookId], references: [id], onDelete: Cascade)
  event               String
  payload             String
  priority            Int       @default(0)
  retryCount          Int       @default(0)
  maxRetries          Int       @default(3)
  scheduledFor        DateTime  @default(now())
  processingStartedAt DateTime?
  processedBy         String?
  createdAt           DateTime  @default(now())
  updatedAt           DateTime  @updatedAt
  deletedAt           DateTime?

  @@index([scheduledFor])
  @@index([priority, scheduledFor])
  @@index([webhookId])
  @@index([deletedAt])
  @@index([processingStartedAt])
}

model DeadLetterWebhook {
  id               String    @id @default(cuid())
  webhookId        String
  webhook          Webhook   @relation(fields: [webhookId], references: [id], onDelete: Cascade)
  event            String
  payload          String
  failureReason    String
  lastAttemptAt    DateTime  @default(now())
  createdAt        DateTime  @default(now())
  updatedAt        DateTime  @updatedAt
  deliveryAttempts String
  deletedAt        DateTime?

  @@index([createdAt])
  @@index([webhookId])
  @@index([deletedAt])
}

model ApiKey {
  id          String    @id @default(cuid())
  keyHash     String    @unique // Bcrypt hash of the API key (never store plaintext)
  keyPrefix   String // First 8 chars of key for identification (not secret)
  userId      String?
  name        String
  permissions String
  active      Boolean   @default(true)
  expiresAt   DateTime?
  lastUsedAt  DateTime?
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt
  deletedAt   DateTime?

  @@index([keyPrefix])
  @@index([userId])
  @@index([active])
  @@index([expiresAt])
  @@index([deletedAt])
  @@index([keyPrefix, deletedAt, active])
}

model IdempotencyKey {
  id         String           @id @default(cuid())
  key        String           @unique
  webhookId  String?
  deliveryId String?
  delivery   WebhookDelivery? @relation(fields: [deliveryId], references: [id], onDelete: SetNull)
  expiresAt  DateTime?
  createdAt  DateTime         @default(now())
  updatedAt  DateTime         @updatedAt
  deletedAt  DateTime?

  @@index([webhookId])
  @@index([createdAt])
  @@index([expiresAt])
  @@index([deletedAt])
}

model Flag {
  id         String    @id @default(cuid())
  resourceId String
  reason     String
  reportedBy String
  resolved   Boolean   @default(false)
  resolvedBy String?
  resolvedAt DateTime?
  createdAt  DateTime  @default(now())
  updatedAt  DateTime  @updatedAt
  deletedAt  DateTime?

  @@index([resourceId])
  @@index([reportedBy])
  @@index([resolved])
  @@index([createdAt])
  @@index([deletedAt])
  @@index([resolved, deletedAt]) // Database-Architect: Optimizes unresolved flag queries with soft delete filter
}

model Resource {
  id              String      @id @default(cuid())
  title           String
  description     String
  benefits        String // JSON array of strings
  url             String
  category        String
  pricingModel    String
  difficulty      String
  tags            String // JSON array of strings
  technology      String // JSON array of strings
  dateAdded       DateTime    @default(now())
  lastUpdated     DateTime    @updatedAt
  popularity      Int         @default(0)
  viewCount       Int         @default(0)
  rating          Float?
  screenshots     String? // JSON array of URLs
  specifications  String? // JSON object
  features        String? // JSON array of strings
  limitations     String? // JSON array of strings
  platforms       String? // JSON array of strings
  license         String?
  icon            String?
  alternatives    String? // JSON array of resource IDs
  status          String      @default("approved")
  submittedBy     String?
  reviewedBy      String?
  reviewedAt      DateTime?
  rejectionReason String?
  qualityScore    Float?
  statusHistory   String? // JSON array of status change records
  deletedAt       DateTime?
  submission      Submission? @relation(fields: [submissionId], references: [id], onDelete: SetNull)
  submissionId    String?     @unique

  @@index([url])
  @@index([category])
  @@index([status])
  @@index([dateAdded])
  @@index([popularity])
  @@index([deletedAt])
  @@index([category, status])
  @@index([status, deletedAt])
  @@index([status, dateAdded]) // -architect: Optimizes resource listing queries with status filter and date ordering
}

model Submission {
  id              String    @id @default(cuid())
  resourceData    String // JSON string of Partial<Resource>
  status          String    @default("pending") // pending, approved, rejected
  submittedBy     String
  submittedAt     DateTime  @default(now())
  reviewedBy      String?
  reviewedAt      DateTime?
  notes           String?
  rejectionReason String?
  resource        Resource?
  deletedAt       DateTime?

  @@index([status])
  @@index([submittedBy])
  @@index([submittedAt])
  @@index([deletedAt])
  @@index([status, deletedAt])
}

model TrackedError {
  id              String    @id @default(cuid())
  message         String
  stack           String?
  component       String?
  severity        String    @default("error") // info, warning, error, critical
  url             String?
  userAgent       String?
  ip              String?
  source          String    @default("client") // client, server, api
  errorHash       String? // For deduplication
  occurrenceCount Int       @default(1)
  firstSeenAt     DateTime  @default(now())
  lastSeenAt      DateTime  @updatedAt
  resolvedAt      DateTime?
  deletedAt       DateTime?

  @@index([severity])
  @@index([source])
  @@index([errorHash])
  @@index([firstSeenAt])
  @@index([lastSeenAt])
  @@index([severity, source])
  @@index([errorHash, resolvedAt])
  @@index([resolvedAt, lastSeenAt]) // Database-Architect: Optimizes unresolved error queries with lastSeen ordering
}

model ErrorMetric {
  id        String    @id @default(cuid())
  date      DateTime  @default(now())
  hour      Int       @default(0)
  severity  String
  source    String
  count     Int       @default(0)
  deletedAt DateTime?

  @@unique([date, hour, severity, source])
  @@index([date])
  @@index([severity, source])
}

model PerformanceMetric {
  id         String    @id @default(cuid())
  timestamp  DateTime
  metricType String // web-vital, api, resource, custom
  metricName String // LCP, INP, CLS, FCP, TTFB, etc.
  value      Float
  rating     String? // good, needs-improvement, poor
  url        String?
  userAgent  String?
  connection String? // network connection type
  metadata   String? // JSON string for additional data
  deletedAt  DateTime?

  // Optimized indexes for performance dashboard queries
  @@index([timestamp, metricType]) // Time range queries with type filter
  @@index([timestamp, metricName]) // Time range queries with name filter
  @@index([metricType, metricName, timestamp]) // Dashboard aggregation queries
  @@index([timestamp, deletedAt]) // -architect: Cleanup queries with soft delete filter
}
